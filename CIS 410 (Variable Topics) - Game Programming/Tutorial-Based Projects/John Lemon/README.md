Cole Pendergraft - Environment, Audio, Dot Product, Particle Effect

Dot Product - The dot product sort of operates under the hood in the game, but I think it is a mechanic that can be used in a lot of different ways. I used the dot product to create a sort of FOV for John Lemon. In FixedUpdate in the PlayerMovement script I create a ray that comes directly off of John's face and points in the direction he is facing. That ray gets passed into a fieldOfVision function, which iterates through a list of all the enemy GameObject in the game. Using the position of the enemy and the origin of the player ray, a new ray is generated that points at the enemy. I then check to make sure that the ray pointing at the enemy doesn't collide with a wall before contacting the enemy using Physics.Raycast, if it does we just skip that enemy as it is outside the FOV. If the check passes, we then normalize the player look vector and the enemy vector and take the dot product between them. The resulting measure is a float between 0 and 1, and essentially encodes how "in front of the player" the enemy is. The smaller the angle between the look ray and the enemy ray the closer the look value gets to 1. For ex, a value of 0.9 suggests the enemy is standing nearly in front of the player, but a value of 0.65 suggests the enemy might be off to the left or right of the player. We use this value to determine what enemies our player can see, and we store the enemy that is most directly in front of the player and use that enemy to perform our symbol color interpolation, so it enables us to single out one enemy from multiple in the player FOV. At present it only works on the Ghosts, for some reason no matter what I do the player can still see Gargoyles through the wall even though the system works for Ghosts. You can see it in operation by puling up the console, if John is staring into a corner or a wall the console will repeatedly print "No enemy in sight.". As soon as you look at the first ghost and it falls within the FOV the system will begin to detect it. If you can't see the console, then just know its used in selecting the enemy object to interpolate the color of the exclamation mark above John's head.

Ethan Pressley - Player Movement, Enemy Indicator, Linear Interpolation

Linear Interpolation - In order to incorporate linear interpolation into the game, I added an '!' TextMeshPro indicator above the player's head whenever the player is in the line-of-sight of an enemy. Inside the dot product code explained above I added code that finds the distance between the player and the enemy (using the Vector3.Distance function) whenever line-of-sight is established. I then take that distance and interpolate it between two experimentally derived values so that when the player is far away from the enemy, the '!' indicator is yellow, and when the player gets closer, it starts turning red. I did this with the Color.Lerp function between Color.Yellow and Color.Red. The easiest way to see this in action is to go into the room immediately to the right of John's spawn, stand in the doorway, and stare at the ghost as it approaches the player. As it gets closer the '!' indicator will turn from yellow to red. We think the flickering we see sometimes in the symbol is due to us running our check in FixedUpdate rather than Update.

Colton Lobdell - All Enemies, Particle Effect

Particle Effect - We had a hard time deciding how to implement a particle effect in a way that would improve upon our game, but ultimately we decided to try to use them to celebrate the player reaching the victory position. We created a Particle System GameObject and positioned it just before the win collider. We attached a collider to that particle system and used it as a trigger to determine when the player approaches the victory space. When the player enters, gold sparks shoot up from the ground in celebration of John's glorious victory.
